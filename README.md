# hm-dianping

### Redis主从
#### 1、安装
在从节点配置文件中增加slaveof或者replicaof masterIp masterPort 即可
#### 2、主从同步
##### 2.1、全量同步
当从节点第一次请求主节点同步数据时会发生全量同步，主节点会将内存中数据刷到RDB文件中，通过文件拷贝或者网络io传输RDB文件，从节点加载该RDB文件
##### 2.2、增量同步
从节点请求数据同步会携带replicaId和offset参数，主节点会将offset之后的记录传输给从节点，从节点收到更新命令后执行更新
##### 2.3、区别
全量使用RDB通过拷贝或者网络io流传输到从节点，从节点flush已有的数据并load新的RDB文件到自己内存中； 增量同步是从节点请求主节点进行同步，请求时带上replicaId和offset，主节点将repl_baklog中offset之后的命令传输给从节点，此外当
从节点因为其他原因offset被覆盖，则需要进行全量同步
#### 3、优化
##### 3.1.尽量避免全量同步 
##### 3.2.当磁盘io较慢或者网络带宽较大时，可以设置通过网络io进行全量同步 
##### 3.3存在多个从节点时，可以采用主-从-从的方式减轻主节点同步时的压力 
##### 3.4.可适当增大repl_baklog的大小，避免从节点的offset较容易被覆盖，从而产生全量同步

### 4.Redis-cluster
### 5.Redis数据结构
#### 5.1 SDS:Simple Dynamic String 简单动态字符串，是为了解决C中字符串存在的问题而封装的数据结构
##### 5.1.1 C中的字符串存在如下问题
###### 5.1.1.1 因为C中字符串底层是一个char数组，获取字符串长度需要遍历数组元素再减一操作，时间复杂度O(N)）
###### 5.1.1.2 二进制安全问题，char数组规定以字符`\0`作为结束标识，所以在数组非结束元素中不能使用`\0`字符
###### 5.1.1.3 字符数组不可修改
##### 5.1.2 SDS如何解决以上问题
###### 5.1.2.1 使用结构实现，结构中有`len`、`alloc`、`flags`、`char buf[]`，对字符串的增删改查都需要调用结构中的方法
###### 5.1.2.2 `len`类型有`uint8_t`、`uint16_t`、`uint32_t`、`uint64_t`，表示该结构体对象中的字符元素个数，在获取字符串长度时直接取`len`值即可，并且`char buf[]`中可以存储`\0`元素，因为不以`\0`为结束标识，但是为了兼容C，最后一个元素的值固定为`\0`
###### 5.1.2.3 `alloc`类型有`uint8_t`、`uint16_t`、`uint32_t`、`uint64_t`，表示该结构体对象中的`char buf[]`数组真实长度，包括空的元素
###### 5.1.2.4 `flags`是标识和控制SDS的头大小，直接读取该值就可知道当前SDS每个字符元素占用的空间
###### 5.1.2.5 `char buf[]`用于存储字符，该数组最后一个值固定为`\0`，同时在结构体中可修改该数组的长度，在新增字符时会进行扩容，并且是预扩容
#### 5.2 IntSet 有序无重复数组
##### 5.2.1 包含结构如下`uint32_t length`、`uint32_t encoding`、`int8_t contents[]`
###### 5.2.1.1 `uint32_t encoding`标识当前结构对象所支持的整数所占大小，可选值有`INTSET_ENC_16`、`INTSET_ENC_32`、`INTSET_ENC_64`
###### 5.2.1.2 `uint32_t length`标识当前结构对象元素个数
###### 5.2.1.3 `int8_t contents[]`真实存储元素，并且是有序存储，连续的内存空间
##### 5.2.2 数组扩容原理
###### 5.2.2.1 首先判断新增的值的`enc`，如果`enc`大于当前`enc`，则需要更新当前结构对象`enc`，并且将数组中的元素从后往前依次升级编码（也就是所占用的内存空间），最后将新元素插入到数组第一个未知或者最后
###### 5.2.2.2 如果`enc`不大于当前`enc`，则首先需要在已有元素中使用二分查找该元素是否存在，如果存在直接返回（同时在查找发方法中会计算新元素应该在数组中插入的未知`&pos`），否则将数组长度+1，再依次将`pos`位置后的元素往后移动一个位置，最后再将新元素插入到数组中
